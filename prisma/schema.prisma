datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

generator client {
  provider = "prisma-client-js"
}

model dragons {
  id            String     @id @default(auto()) @map("_id") @db.ObjectId
  dragonId      Int        @unique
  name          String     @unique
  globalRank    Int
  rarity        Rarity
  familyName    String?
  breedable     Boolean
  elements      Elements[]
  image         String
  thumbnail     String
  baseSpeed     Int
  maxSpeed      Int
  maxDamage     Int
  category      Int
  skills        Skill[]    @relation(fields: [skillsId], references: [id])
  skillsId      String[]   @db.ObjectId
  speedScore    Float
  damageScore   Float
  elementsScore Int
  rarityScore   Int
  skillsScore   Int
  dragonScore   Float
  rank          Int
  rating        Rating?
}

model Rating {
  cooldown         Int? // Skill Cooldown
  value            Int? // Skill yields consistent benefits in proportion to drawbacks if any (health sacrifice, random skill, etc)
  versatility      Int? // Skill effectiveness in various situations
  potency          Int? // Damage potential
  primary_coverage Int? // Defensive capability (excluding guards, twds)
  crit_coverage    Int? // Offensive capability (points deduced for elements that crit a primary that subsequently crits your own)
  viability        Int? // Performance in arenas against meta picks
  usability        Int? //  How many of itâ€™s 4 masters arenas can you use it in
  id               String   @id @default(auto()) @map("_id") @db.ObjectId
  dragons          dragons? @relation(fields: [dragonsId], references: [id])
  dragonsId        String?  @unique @db.ObjectId
}

model ownedDragons {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @unique
  ids    Int[]
}

model Skill {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  name        String    @unique
  skillType   Int
  description String
  dragons     dragons[] @relation(fields: [dragonsId], references: [id])
  dragonsId   String[]  @db.ObjectId
}

enum Elements {
  pu
  d
  f
  wr
  i
  w
  m
  l
  mg
  li
  ch
  el
  ti
  wd
  pr
  e
  p
  hp
  bt
  so
  dr
}

enum Rarity {
  M
  H
  L
  R
  C
  V
  E
}

model User {
  id            String          @id @default(auto()) @map("_id") @db.ObjectId
  name          String?
  email         String?         @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]
  role          Role            @default(USER)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

enum Role {
  GOD
  ADMIN
  USER
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @id @map("_id")
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, credentialID])
}
